
"""
"""
module GridStruct

using BoxStruct
using CoefHelpers
using LinearAlgebra

export Grid, carttosphere, mcoef!, lcoef!, getparticledict
export evallocalpotential, evaldirectpotential, evalmultipolepotential

mutable struct Grid
    """
    Represents a box in the 3D FMM.

    fields:
    """
    boxes::Dict{Int64,Box}
    particles::Dict{Int64,Tuple{Tuple{Float64,Float64,Float64},Float64}}
    numparticles::Int64
    levels::Dict{Int64,Set{Int64}}
    numlevels::Int64
    minbound::Array{Float64,1}
    maxbound::Array{Float64,1}
    center::Array{Float64,1}
    size::Int64
    signarray::Array{Array{Int64,1},1}
    nmin::Int64
    function Grid()
        this = new()
        this.boxes = Dict{Int64,Box}()
        this.particles = Dict{Int64,Tuple{Tuple{Float64,Float64,Float64},Float64}}()
        this.numparticles = 0
        this.levels = Dict{Int64,Set{Int64}}()
        this.numlevels = 0
        this.minbound = zeros(Float64,3)
        this.maxbound = zeros(Float64,3)
        this.center = zeros(Float64,3)
        this.size = 1
        # An array for calculating vertices and centers of refinement boxes
        # arranged s.t. |7,8|5,6|
        #              |1,2|3,4|
        this.signarray = [[-1,-1,1],[-1,-1,-1],[1,-1,1],[1,-1,-1],
                    [1,1,1],[1,1,-1],[-1,1,1],[-1,1,-1]]
        this.nmin = 2
        @assert this.nmin > 1 ["minimum number of particles in box must be greater than 1"]
        return this
    end
end

function carttosphere(particleid::Int64, box1::Box, grid::Grid)
    """
    Yields the spherical coordinates for a particle
    with respect to the center of box1.

    inputs:
        particles: a dictionary of particles in the grid.
    returns: a triple of the spherical coordinates of the particles with
        respect to the center of box1.
    """
    # the center of the box
    cx = box1.center[1]
    cy = box1.center[2]
    cz = box1.center[3]

    particle = grid.particles[particleid]
    (x,y,z) = particle[1]
    ρ = sqrt((x-cx)^2 + (y-cy)^2 + (z-cz)^2)
    θ = atan((y-cy)/(x-cx))
    ϕ = acos((z-cz)/ρ)

    return ρ, θ, ϕ
end

function mcoef!(box::Box, p::Int64, grid::Grid)
    """
    Find the relevant multipole coefficients Mnm for a given box, where
        M_n^m =
        sum_i=1^numparticles [q_i * r_i^n * Y_n^-m(theta_i,phi_i)]

    inputs:
    returns: An array of the coefficints M_nm for a given box. E.g.
        [M_0^0 M_1^-1 M_1^0  M_1^1... M_p^p]
    """
    s = box.numparticles
    ns = spherical_harmonic_indices(p)[1]
    len = length(ns)
    Yqmatx = zeros(ComplexF64,len,s)
    Mnm = zeros(ComplexF64,len)
    ρnmatx = zeros(len, s)
    i = 1
    for partid in box.particles
        particle = grid.particles[partid]
        ρ, θ, ϕ = carttosphere(partid,box,grid)
        for j = 1:len
            ρnmatx[j,i] = ρ^ns[j]
        end
        q = particle[2]
        Yqmatx[:,i] = q * spherical_harmonics(p, θ, ϕ, true)
        i += 1
    end
    for i = 1:len
        m = ρnmatx[i,:] * Yqmatx[i,:]'
        Mnm[i] = m[1]
    end
    box.multipole_coef = Mnm
end # fun

function lcoef!(box1::Box, p::Int64, particles::Set{Int64}, grid::Grid)
    """
    Calculates the local expansion coefficients for the potential generated by
    the particles in a given set with respect to the center of box1.
    """
    s = length(particles)
    ns = spherical_harmonic_indices(p)[1]
    nspow = spherical_harmonic_indices(p+1)[1]
    len = length(ns)
    Yqmatx = zeros(ComplexF64,len,s)
    Lnm = zeros(ComplexF64,len)
    if s == 0
        box1.local_coef = Lnm
        return
    end
    ρnmatx = zeros(len, s)
    i = 1
    for partid in particles
        ρ, θ, ϕ = carttosphere(partid,box1,grid)
        for j = 1:len
            ρnmatx[j,i] = ρ^-nspow[(j+1)]
        end
        q = grid.particles[partid][2]
        Yqmatx[:,i] = q * spherical_harmonics(p, θ, ϕ, true)
        i += 1
    end #particles
    for i = 1:len
        l = ρnmatx[i,:] * Yqmatx[i,:]'
        Lnm[i] = l[1]
    end
    box1.local_coef = Lnm
end#function

function getparticledict(box::Box, grid::Grid)
    """
    Creates a dictionary of particles in the box with particle id as key
    and a tuple of the cartesian coordinates of the particle (with respect to
    the grid center) and the charge of the particle as value.
    """
    particleids = box.particles
    len = length(particleids)
    particledict = Dict{Int64,Tuple{Tuple{Float64,Float64,Float64},Float64}}()
    for particleid in particleids
        particledict[particleid] = grid.particles[particleid]
    end
    return particledict
end

function evallocalpotential(box::Box, grid::Grid, p::Int64)
    """
    Calculates the potential at each charge in box from box's local expansion
    """
    particles = getparticledict(box,grid)

    ns,ms = spherical_harmonic_indices(p)
    len = length(ns)
    ρs = ones(len)

    Lmn = box.local_coef
    ψ = 0
    particleids = keys(particles)
    for particleid in particleids
        ρ, θ, ϕ = carttosphere(particleid, box, grid)
        ρn = (ρ * ρs).^ns
        Ynm = spherical_harmonics(p, θ, ϕ)
        terms = ρn .* Ynm
        ψ += Lmn' * terms
    end

    return ψ
end #evalpotential

function evaldirectpotential(box::Box, grid::Grid, p::Int64,
    particledict::Dict{Int64,Tuple{Tuple{Float64,Float64,Float64},Float64}})
    """
    Calculates the potential at particles in box due to particles in
    particledict
    """
    boxparticledict = getparticledict(box,grid)
    ϕ = 0
    for boxparticleid in keys(boxparticledict)
        for particleid in keys(particledict)
            if particleid != boxparticleid
                coordsj = boxparticledict[boxparticleid][1]
                coordsi = particledict[particleid][1]
                qi = particledict[particleid][2]
                den = norm(coordsj.-coordsi)
                ϕ += qi/den
            end
        end
    end

    return ϕ
end

function evalmultipolepotential(box1::Box, box2::Box, grid::Grid, p::Int64)
    """
    Calculates the potential at each charge in box1 from box2's multipole expansion
    coefficients
    """
    ns,ms = spherical_harmonic_indices(p)
    len = length(ns)
    ρs = ones(len)

    Mmn = box2.multi_coef
    particles = getparticledict(box1,grid)

    ϕ = 0
    for particleid in particles
        ρ, θ, ϕ = carttosphere(particleid, box1, grid)
        ρn = (ρ * ρs).^(ns + 1)
        Ynm = spherical_harmonics(p, θ, ϕ)
        terms = ρn .* Ynm
        ϕ += Mmn' * terms
    end

    return ϕ
end #evalpotential

end  # module GridStruct
